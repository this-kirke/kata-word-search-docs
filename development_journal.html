<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Word Search Kata: Development Journal</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom_dark_theme.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Word Search Kata
   </div>
   <div id="projectbrief">A word search puzzle solver.  Given a text file consisting of a list of words, and a series of rows of single-character lists representing the word search grid, this program searches for the words in the grid and return a set of x,y coordinates for each word found.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('development_journal.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Development Journal </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><hr/>
<h3>Monday, July 6, 2020</h3>
<h3>6:00 CDT</h3>
<p>Changed all array types in libword_search to <a class="el" href="structSlice.html">Slice</a> types. Added documentation strings to libcore and libword_search. </p><hr/>
<h3>Monday, July 6, 2020</h3>
<h3>12:30 CDT</h3>
<p>Ok, so here's the next update - While reviewing the basic types I defined for libword_search, I noticed that many of them include fields of arrays of types. For each of these arrays, length has to be tracked or some convention followed in order to determine the length of the array. The good news is, we can solve the same problem wherever it occurs in the same way. In sort of the same approach used for WordSearch__Word, we're going to track the length of all arrays in a structure type. We can define a single type (call it a <a class="el" href="structSlice.html">Slice</a>), which holds a pointer to data, and keeps track of the allocated size, length of the array, and element size. We will lose a direct reference to the type - that burden will now fall on the developer - but it's a small price to pay to have consistent handling of arrays of generic types.</p>
<p>Added macro ELEMENT_COUNT for calculating the number of elements in array types (NOT pointer-to arrays!). This is just convenience, so we don't have to write sizeof( array ) / sizeof( array[ 0 ] ) wherever we need it.</p>
<p>Added <a class="el" href="structSlice.html">Slice</a> type (defined in lib/core/include/slice.h) with macros for initializing, accessing and otherwise manipulating slices. Tests for each macro are included in lib/core/test/test__core__slice.cpp</p>
<p><a class="el" href="structSlice.html">Slice</a> struct contains a pointer to the underlying data, as well as metadata describing the length of the slice in elements, the capacity (in elements) of the underlying memory, and the element size of each element stored within.</p>
<p>Macros defined include:</p>
<p>slice__default: Description: Declares an empty slice, with all fields zero'd. Usage: <a class="el" href="structSlice.html">Slice</a> empty = slice__default;</p>
<p>slice__init: Description: Initializes a slice given a pointer to data of known length. Usage: size_t array_size = 4; int* array = malloc( array_size ); <a class="el" href="structSlice.html">Slice</a> slice = <a class="el" href="group__slice.html#gadebf28cefce13ca6ed1144058972028f" title="Fully initialize a slice with an array of known length. ">slice__init( array, array_size, sizeof( int ) )</a>;</p>
<p>slice__from_array: Description: Initializes a slice given a stack array (Important: not a pointer-to data). Usage: int array[ 4 ] = { 0, 1, 2, 3 }; <a class="el" href="structSlice.html">Slice</a> slice = <a class="el" href="group__slice.html#gad140dc32da9d1ef1fa62c7c165f2e46f" title="Initialize a slice from a stack-allocated array. ">slice__from_array( array )</a>;</p>
<p>slice__string_literal: Description: Initializes a slice given a string literal. The string literal can be declared inline. Usage: <a class="el" href="structSlice.html">Slice</a> hello = slice__string_literal( "Hello World!" );</p>
<p>slice__index: Description: Returns the element at the specified index. Indices are zero-based. Modifying the returned element will modify the slice. Usage: <a class="el" href="structSlice.html">Slice</a> slice = slice__string_literal( "Hello" ); assert( <a class="el" href="group__slice.html#ga641d5378df1376add1b932e8a64af0e2" title="Retrieves the element of the Slice corresponding to the the specified index. ">slice__index( &amp;slice, char, 4 )</a> == 'o' );</p>
<p>slice__data: Description: Returns a pointer to the underlying data of a slice, type-cast to the specified type. This can be dangerous if the incorrect type is specified, use with caution. Usage: <a class="el" href="structSlice.html">Slice</a> slice = slice__string_literal( "Hello" ); </p><h2>const char* slice_data = <a class="el" href="group__slice.html#ga1fbe3f1d4df19060519793abe4eddb99" title="Retrieves a pointer to the underlying data of the specified Slice. ">slice__data( &amp;slice, char )</a>; </h2>
<h3>Monday, July 6, 2020</h3>
<h3>11:42 CDT</h3>
<p>Alright, after the 4th of July weekend it's time to get back to this project in earnest. I've got a stable foundation for further development, now it's time to test, implement, refacter FTW!</p>
<p>I'm going to adopt a middle-out approach. I think the first step is to actually define the structures which I'll use to hold the word search data. From there I can write the actual search algorithm, folowed by the output mechanism and finally the parser. The parse should close the loop, giving us a complete word search application.</p>
<p>Types defined:</p>
<p>WordSearch__Direction: An enumerator defining the cardinal and intermediate directions, which comprise all of the directions one can move on the word search puzzle grid.</p>
<p><a class="el" href="structWordSearch____GridEntry.html">WordSearch__GridEntry</a>: A structure containing data relevant to grid entries. Preliminary fields include row, column, and character value. This may evolve to include references to neighbor entries.</p>
<p><a class="el" href="structWordSearch____Grid.html" title="This structure contains metadata describing the grid, such as its width and height, as well as a pointer to a Slice containing all of the grid&#39;s entries. ">WordSearch__Grid</a>: A structure defining the actual word search grid. Preliminiary fields include metadata describing the grid dimensions, as well as a pointer to an array of <a class="el" href="structWordSearch____GridEntry.html">WordSearch__GridEntry</a> structs.</p>
<p>WordSearch__Word: A structure containing a word from a word search puzzle. Fields include metadata describing the word length, as well as a pointer to an array of characters comprising the word. I could just use const char* in place of this structure, and use the null-terminator convention for determining length. However, this approach allows flexibility in the future, and does not rely on convention for correctness - lots of overflow errors happen because arrays are not null-terminated when they should be.</p>
<p><a class="el" href="structWordSearch____Puzzle.html">WordSearch__Puzzle</a>: A structure which defines the entire word search puzzle. This includes an array of words to be found, as well as the grid in which they can be found. With references to this data, we can perform all operations necessary to obtain a solution.</p>
<p><a class="el" href="structWordSearch____WordSolution.html">WordSearch__WordSolution</a>: This is a basic tuple structure, associating a WordSearch__Word with an array of <a class="el" href="structWordSearch____GridEntry.html">WordSearch__GridEntry</a>. An array of these will be the main output of the search algorithm.</p>
<p>Ok, all those types are defined, I'm going to commit them. I can mentally walk through the algorithm with these types, so I think we've got a stable foundation for solving the word search problem. However, there's one problem I'd like to solve first, and I'll put that in the next entry. </p><hr/>
<h3>Monday, July 6, 2020</h3>
<h3>10:58 CDT</h3>
<p>Just did some extra project reorganization. I realized there are a lot of infrastructure-type structures and routines which I'll have to implement, which are broader than just word searches. In the interest of keeping the project modular, and possibly being able to re-use much of the general-purpose implementation, I've factored that out into another, higher-level library. I promise this is the end of abstraction :)</p>
<p>New project structure is like this: </p><pre class="fragment">         libcore
            |
      libword_search
            |
     kata_word_search  
</pre> <hr/>
<h3>Friday, July 3, 2020</h3>
<h3>11:03 CDT</h3>
<p>Completed some project reorganization. I now have placeholders for a libword_search library holding the main types and procedures used to manipulate generic word search puzzles, and an executable kata_word_search which will actually solve puzzles fed to it, and enforce any rules from the application specification (square grid, for example).</p>
<p>Added first test, an acceptance test in exec/kata_word_search/test/test__kata_word_search.cpp. This runs the kata_word_search executable with sample input, and verifies that the correct solution is returned as output. </p><hr/>
<h3>Monday, June 29, 2020</h3>
<h3>23:51 CDT</h3>
<p>Project skeleton created:</p><ul>
<li>CMake build system</li>
<li>Catch2 for testing</li>
<li>gcov with lcov and genhtml for code coverage reporting</li>
<li>Doxygen for documentation generation</li>
<li>doxygen_dark_theme for pretty documentation.</li>
<li>Travis.CI build on push </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
